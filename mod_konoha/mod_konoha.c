/* 
**  mod_konoha.c -- Apache sample konoha module
**  [Autogenerated via ``apxs -n konoha -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_konoha.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /konoha in as follows:
**
**    #   httpd.conf
**    LoadModule konoha_module modules/mod_konoha.so
**    <Location /konoha>
**    SetHandler konoha
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /konoha and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/konoha 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_konoha.c
*/ 
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"

#include "http_log.h"
#include <konoha1.h>
#include <konoha1/inlinelibs.h>

#define PATHSIZE 1024

typedef struct _konoha_config {
    char *handler;
    char *package_path;
} konoha_config_t;

static int konoha_initialized = 0;
static konoha_t konoha;

module AP_MODULE_DECLARE_DATA konoha_module;

/* utility of read from POST body */
#if 0
static int util_read(request_rec *r, const char **rbuf)
{
    int rc;

    if (r->method_number != M_POST) {
        return DECLINED;
    }

    if ((rc = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)) != OK) {
        return rc;
    }

    if (ap_should_client_block(r)) {
        char argsbuffer[HUGE_STRING_LEN];
        int rsize, len_read, rpos=0;
        long length = r->remaining;
        *rbuf = apr_pcalloc(r->pool, length + 1);

        while ((len_read = ap_get_client_block(r, argsbuffer,
                        sizeof(argsbuffer))) > 0 ) {
            if ((rpos + len_read) > length) {
                rsize = length - rpos;
            }
            else {
                rsize = len_read;
            }
            memcpy((char *)*rbuf + rpos, argsbuffer, rsize);
            rpos += rsize;
        }
    }

    return rc;
}
#endif

#if 0
/* utility of read from POST body form */
static int read_post(request_rec *r, apr_table_t **tab)
{
    const char *data;
    const char *key, *val, *type;
    int rc = OK;

    if (r->method_number != M_POST) {
        return DECLINED;
    }

    type = apr_table_get(r->headers_in, "Content-Type");
    if (strcasecmp(type, "application/x-www-form-urlencoded") != 0) {
        return DECLINED;
    }

    if ((rc = util_read(r, &data)) != OK) {
        return rc;
    }

    if (*tab) {
        apr_table_clear(*tab);
    }
    else {
        *tab = apr_table_make(r->pool, 8);
    }

    while (*data && (val = ap_getword(r->pool, &data, '&'))) {
        key = ap_getword(r->pool, &val, '=');

        ap_unescape_url((char *)key);
        ap_unescape_url((char *)val);

        apr_table_merge(*tab, key, val);
    }

    return OK;
}
#endif

/* call Wsgi.main() */
void start_application(request_rec *r, CTX ctx)
{
    extern char **environ;
    char **env_p;
    kmethodn_t mn = knh_getmn(ctx, STEXT("application"), MN_NONAME);
    kclass_t cid = knh_getcid(ctx, STEXT("konoha.wsgi.Wsgi"));
    //ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, "mn=%d,cid=%d,cid2=%d\n", mn, cid, cid2);
    kMethod *mtd = knh_NameSpace_getMethodNULL(ctx, NULL, cid, mn);
    BEGIN_LOCAL(ctx, lsfp, K_CALLDELTA+3);

    /* set args */
    kMap *env_map = new_DataMap(ctx);
    char key[128] = {0};
    for (env_p = environ; *env_p != NULL; env_p++) {
        ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, "env: %s", *env_p);
        char *val = strchr(*env_p, '=');
        if (val != NULL) {
            val += 1;
            size_t keylen = val - *env_p - 1;
            strncpy(key, *env_p, keylen);
            key[keylen] = '\0';
            ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, "key=%s", key);
            ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, "val=%s", val);
            knh_DataMap_setString(ctx, env_map, key, val);
        }
    }

    KNH_SETv(ctx, lsfp[K_CALLDELTA+1].o, env_map);
    KNH_SCALL(ctx, lsfp, 0, mtd, 2);
    END_LOCAL(ctx, lsfp);
    ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, "lsfp[0]=%s", S_totext(lsfp[0].s));
    if (mtd == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, "mtd is NULL");
    }
    //assert(mtd != NULL);
}

/* konoha handler */
static int konoha_handler(request_rec *r)
{
    if (strcmp(r->handler, "konoha")) {
        return DECLINED;
    }
    r->content_type = "text/plain";
    r->content_encoding = "utf-8";

    /* get config */
    konoha_config_t *conf = (konoha_config_t *)ap_get_module_config(r->per_dir_config, &konoha_module);
    char *handler = conf->handler;
    char *package_path = conf->package_path;

    /* call konoha main */
    int ret;
    int argc = 3;
    setenv("KONOHA_PACKAGE", package_path, 0);
    const char *argv[] = {
        "/usr/local/bin/konoha",
        "-a2",
        handler
    };
    if (!konoha_initialized) {
        konoha_initialized = 1;
        konoha_ginit(argc, argv);
        konoha = konoha_open();
        //knh_loadPackage(konoha, STEXT("konoha.wsgi"));
    }
    ap_rprintf(r, "argc=%d\n", argc);
    int i;
    for (i = 0; i < argc; i++) {
        ap_rprintf(r, "argv[%d]=%s\n", i, argv[i]);
    }
    ret = konoha_main(konoha, argc, argv);
    start_application(r, konoha);
    //konoha_close(konoha);
    if (ret != 0) {
        ap_rputs("Konoha closed with error.", r);
    }
    ap_rprintf(r, "KonohaHandler=\"%s\"\n", handler);
    return OK;
}

/* copy .conf arguments */
static const char *set_handler(cmd_parms *cmd, void *vp, const char *arg)
{
    (void)cmd;
    konoha_config_t *conf = (konoha_config_t *)vp;
    strncpy(conf->handler, arg, PATHSIZE - 1);
    return NULL;
}

/* copy KonohaHandler to set KONOHA_PACKAGE environment variable */
static const char *set_package_path(cmd_parms *cmd, void *vp, const char *arg)
{
    (void)cmd;
    konoha_config_t *conf = (konoha_config_t *)vp;
    strncpy(conf->package_path, arg, PATHSIZE - 1);
    return NULL;
}

/* configure konoha create dir */
static void *konoha_cdir_cfg(apr_pool_t *pool, char *arg)
{
    (void)arg;
    konoha_config_t *conf;
    conf = (konoha_config_t *)apr_palloc(pool, sizeof(konoha_config_t));
    conf->handler = (char *)apr_palloc(pool, sizeof(char) * PATHSIZE);
    conf->package_path = (char *)apr_palloc(pool, sizeof(char) * PATHSIZE);
    return (void *)conf;
}

/* konoha commands */
static const command_rec konoha_cmds[] = {
    AP_INIT_TAKE1("KonohaHandler",
        set_handler,
        NULL,
        OR_ALL,
        "set konoha handler"),
    AP_INIT_TAKE1("PackagePath",
        set_package_path,
        NULL,
        OR_ALL,
        "set konoha package path"),
    { NULL, {NULL}, NULL, 0, RAW_ARGS, NULL }
};

/* konoha register hooks */
static void konoha_register_hooks(apr_pool_t *p)
{
    (void)p;
    ap_hook_handler(konoha_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA konoha_module = {
    STANDARD20_MODULE_STUFF,
    konoha_cdir_cfg,       /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    konoha_cmds,           /* table of config file commands       */
    konoha_register_hooks  /* register hooks                      */
};

